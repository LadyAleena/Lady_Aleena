package Page::List::File;
use v5.8.8;
use strict;
use warnings;
use Exporter qw(import);

our @EXPORT_OK = qw(file_directory file_path file_list file_menu print_file_menu);

use File::Basename;
use File::Spec;

use Page::Path qw(base_path);
use Page::HTML qw(anchor list);
use Util::Convert qw(textify searchify);
use Util::Sort qw(article_sort name_sort);
use Util::Columns qw(number_of_columns);

# file_directory returns the directory by type of data wanted.
## The default data directory is 'data'.
## Other options for type are:
### text returns the text file for various pages.
### audio, images, and css return urls.
### imagesd returns the images directory, but not in url format.

sub file_directory {
  my ($dir, $type) = @_;
  $dir =~ s/ /_/g;
  $type = $type ? $type : 'data';
  return base_path($type)."/$dir";
}

# file_path returns the path of a file by type of data wanted
## The default directory is data.
### To change the directory, use the 'base' option.
## The default file extention is txt.
### To the the file extention, use the 'ext' option.
sub file_path {
  my ($directory, $filename, $opt) = @_;

  my $base = $opt->{'base'} ? $opt->{'base'} : 'data';
  my $ext  = $opt->{'ext'}  ? $opt->{'ext'}  : 'txt';

  my $file_name = basename($0);

  my $root_path = base_path('path');
  my $root_data = base_path($base);

  my $relative_path = File::Spec->abs2rel($file_name, $root_path);
     $relative_path =~ s/\.\w+$//;
     $relative_path =~ s/working(?:\/|\\)//;

  my $data = undef;
  if ($directory && $filename) {
    $data = "$root_data/$directory/$filename";
  }
  elsif ($directory && !$filename) {
    $data = "$root_data/$directory.$ext";
  }
  elsif (!$directory && $filename) {
    $data = "$root_data/$relative_path/$filename";
  }
  else {
    $data = "$root_data/$relative_path.$ext";
  }

  return $data;
}

# file_list returns a list of the contents in a directory but is not recursive.
## There are options:
### 'type' returns only the wanted type files or directories.
### 'uppercase' returns only files that begin with an initial uppercase letter.
### 'sort' returns a the list sorted. The options are 'article' or 'name'.
### 'full path' returns the list with the files' full paths.

sub file_list {
  my ($directory, $opt) = @_;

  opendir(my $dir, $directory) || die "Can't open $directory. $!";
  my @files = File::Spec->no_upwards(readdir($dir));
  closedir($dir);
  chomp @files;

  @files = grep { -f "$directory/$_" } @files if $opt->{'type'} && $opt->{'type'} =~ /^f/;
  @files = grep { -d "$directory/$_" } @files if $opt->{'type'} && $opt->{'type'} =~ /^d/;
  @files = grep { /^\p{uppercase}/ }   @files if $opt->{'uppercase'} && $opt->{'uppercase'} =~ /^[yt1]/;  # Thank you [tye]!

  if ($opt->{'sort'}) {
    my $sort = $opt->{'sort'};
    my $sort_sub = $sort eq 'name'    ? \&name_sort    :
                   $sort eq 'article' ? \&article_sort :
                   undef;
    if ($sort_sub) {
      @files = sort { $sort_sub->($a, $b) } @files;
    }
    else {
      @files = sort @files;
    }
  }

  @files = map { s/\.txt//; s/_/ /g; $_ } @files if $opt->{'text'}      && $opt->{'text'}      =~ /^[yt1]/;
  @files = map { "$directory/$_" }        @files if $opt->{'full path'} && $opt->{'full path'} =~ /^[yt1]/;

  return @files
}

# file_menu returns a list of links for any sub pages generated by cgi param
## The first parameter is the name of the parameter being used in the script.
## The second parameter is the list of possible parameter values.
## The third is the current value selected.
sub file_menu {
  my($param, $list, $select) = @_;
  my @params = map {
    [
      anchor(textify($_, { 'parens' => 'yes' }), { 'href' => '?'.searchify($param).'='.searchify($_), 'title' => textify($_) }),
      { 'class' => $select && $select eq $_ ? 'active' : 'inactive' }
    ]
  } @$list;
  return \@params;
}

# print_file_menu prints file_menu and has the additional parameter of columns
sub print_file_menu {
  my ($param, $list, $page, $cols) = @_;
  my $file_menu = file_menu($param, $list, $page);
  my $count = @$list;
  my $class = $cols ? number_of_columns(2, $count, 'yes') : undef;
  list(4, 'u', $file_menu, { 'class' => $class });
}

=pod

=encoding utf8

=head1 AUTHOR

Lady Aleena

=head1 LICENSE AND COPYRIGHT

This module is free software; you can redistribute it and/or modify it under the same terms as Perl itself. See L<perlartistic>.

Copyright Â© 2020, Lady Aleena C<(aleena@cpan.org)>. All rights reserved.

=cut

1;